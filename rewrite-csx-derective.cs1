#!/usr/bin/env -S dotnet run --file
#:package Lestaly.General@0.114.0
#:package Kokuban@0.2.0
using System.Text.RegularExpressions;
using Kokuban;
using Lestaly;

var settings = new
{
    RewriteSettings = new RewriteSettings(
        SearchExtension: ".csx",
        RewriteExtension: ".cs1",
        Shebang: "#!/usr/bin/env -S dotnet run --file",
        RefFilePackage: "RefFile@0.2.0"
    ),
};

return await Paved.ProceedAsync(async () =>
{
    using var signal = new SignalCancellationPeriod();

    Console.WriteLine("Rewrite dotnet-script directives");
    while (true)
    {
        Console.Write(">");
        var input = Console.ReadLine()?.Trim().Unquote().Trim();
        if (input == null) break;
        if (input.IsWhiteSpace()) continue;

        try
        {
            if (input.AsDirectoryInfo() is var dir && dir.Exists)
            {
                foreach (var file in dir.GetFiles($"*{settings.RewriteSettings.SearchExtension}", SearchOption.AllDirectories))
                {
                    await rewriteScriptAsync(file, signal.Token);
                }
            }
            else if (input.AsFileInfo() is var file && file.Exists)
            {
                await rewriteScriptAsync(file, signal.Token);
            }
            else
            {
                Console.WriteLine(Chalk.Yellow["No file"]);
            }
        }
        catch (PavedMessageException ex)
        {
            var chalk = ex.Kind switch { PavedMessageKind.Information => Chalk.Gray, PavedMessageKind.Warning => Chalk.Yellow, _ => Chalk.Red, };
            Console.WriteLine(chalk[ex.Message]);
        }
        Console.WriteLine();
    }
});

async ValueTask rewriteScriptAsync(FileInfo file, CancellationToken cancelToken)
{
    Console.WriteLine($"File: {file.FullName}");
    var rewriteFile = file.GetAnotherExtension(settings.RewriteSettings.RewriteExtension);
    if (rewriteFile.Exists)
    {
        Console.WriteLine(Chalk.Yellow[".. Skip: Already exists .cs1 file"]);
        return;
    }

    var scriptLines = await file.ReadAllLinesAsync(cancelToken);
    var rewriteLines = convertScriptSource(scriptLines, settings.RewriteSettings);

    await file.WriteAllLinesAsync(rewriteLines, cancelToken);
    file.Rename(rewriteFile.FullName);
    Console.WriteLine(Chalk.Green[$".. Rewrite to {rewriteFile.Name}"]);
}

IEnumerable<string> convertScriptSource(IEnumerable<string> source, RewriteSettings settings)
{
    var loadFiles = new List<string>();
    var usingBlock = ScanState.None;
    var first = true;
    foreach (var line in source)
    {
        if (first)
        {
            first = false;
            yield return settings.Shebang;
            if (line.StartsWith("#!")) continue;
        }

        if (line.Match(@"^\s*#\s*r\s+""nuget\s*:\s*(?<name>[a-zA-Z0-9\-\._]+)\s*(?:,| )\s*(?<version>.+)\s*""") is var package && package.Success)
        {
            var name = package.Groups["name"].Value;
            var version = package.Groups["version"].Value;
            yield return @$"#:package {name}@{version}";
            continue;
        }
        if (line.Match(@"^\s*#\s*nullable\s+(?<value>.+)\s*") is var nullable && nullable.Success)
        {
            var value = nullable.Groups["value"].Value;
            if (value.IsNotWhite() && value != "enable") yield return @$"#:property Nullable={value}";
            continue;
        }
        if (line.Match(@"^\s*#\s*r\s+""sdk\s*:\s*(?<name>.+)\s*""") is var sdk && sdk.Success)
        {
            var name = sdk.Groups["name"].Value;
            yield return @$"#:sdk {name}";
            continue;
        }
        if (line.Match(@"^\s*#\s*load\s+""(?<path>.+)""") is var load && load.Success)
        {
            var path = load.Groups["path"].Value;
            if (loadFiles.Count <= 0) yield return $"#:package {settings.RefFilePackage}";
            if (usingBlock < ScanState.Ended) loadFiles.Add(path);
            continue;
        }

        if (usingBlock == ScanState.None)
        {
            if (line.RoughStartsAny(["using"])) usingBlock = ScanState.Started;
        }
        else if (usingBlock == ScanState.Started)
        {
            if (!line.RoughStartsAny(["using"]))
            {
                usingBlock = ScanState.Ended;
                foreach (var path in loadFiles)
                {
                    var refPath = path;
                    if (path.EndsWith(settings.SearchExtension)) refPath = $"{path[..^settings.SearchExtension.Length]}{settings.RewriteExtension}";
                    yield return @$"[assembly: RefFile(""{refPath}"")]";
                }
            }
        }

        yield return line;
    }
}

record RewriteSettings(string SearchExtension, string RewriteExtension, string Shebang, string RefFilePackage);
enum ScanState { None, Started, Ended, }